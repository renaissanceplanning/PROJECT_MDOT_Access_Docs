#Chapter 30 tools (transit project study area)
#Author: Alex Bell, Renaissance Planning
#Last updated: August 2019
"""
This module facilitates the designation of a project study area
and the execution of travel time savings analysis procedures
for Maryland Chapter 30 scoring purposes. It also provides support
for transit network development for users following the "Add GTFS
to Network Dataset" toolbox (ESRI) workflow in the ArcGIS Basic
license level.

Project Study Areas
------------------------
Project study areas are used to define the area in which impacts of 
projects are measured. They are dynamically determined based on the
travel mode affected by the project, the expected usership of the 
facilities affected by the project, and travel time changes wrought
by the project.  

For transit projects, the study area is defined based on transit
and highway travel time skims.  Zones overlapping project limits are
provided by the user as a list of zone IDs, and zones within user-
specified travel time tolerances by each mode are included in the 
project's study area.

See Also
---------
gp_listStudyAreaZones
gp_mapStudyArea


Travel Time Savings Calculation
--------------------------------
Travel time savings summarizes the impact of a given transportation
project by comparing travel times between a "build" condition (with the
project) to a "base" condition (without the project). The difference
in travel time between each O-D pair is weighted by the number of trips
estimated between the zones in deriving average travel time savings. The
procedures offered in this module assume a constant trip table and are
used for estimating the travel time savings that accrue to current 
transit riders. The derivation and utilization of these estimates
alongside travel time savings benefits accruing to motorists due to
increased transit ridership are spelled out in the Chapter 30 
Technical Guide.

The matrix processing procedures required for the travel time savings
estimates are facilitated by the ZoneMatrixManager class and executed
using the travelTimeSavings function.

See Also
---------
gp_travelTimeSavings


Transit Network Development Support
-----------------------------------------
For transit network development, the "Add GTFS to Network Dataset"
toolbox workflow requires ArcGIS Standard or Advanced license levels
to run step 2 (stops-to-streets connectors). An alternative function for
generating connection features is provided for ArcGIS Basic users.
- createStopsToStreetsConnectors

See Also
---------
gp_StopsToStreetsConnectors


Classes and Functions
----------------------
"""

import arcpy
import numpy as np
import mma
import uuid
import math

#globals

global _FIELD_TYPE_DICT, _FIELD_DTYPE_DICT

_FIELD_TYPE_DICT = {
	"String":"TEXT",
	"SmallInteger": "SHORT",
	"Integer": "LONG",
	"Single": "FLOAT",
	"Double": "DOUBLE",
	"Date": "DATE"
	}
_FIELD_DTYPE_DICT = {
	"String": "U",
	"SmallInteger": "<i4",
	"Integer": "<i4",
	"Single": "<f8",
	"Double": "<f8",
	"Date": "M" #?
	}
	
	
###################
## ARCPY HELPERS ##
###################

def _getWorkspaceType(path):
	desc = arcpy.Describe(path)
	try:
		return desc.workspaceType
	except AttributeError:
		return _getWorkspaceType(desc.path)
	

def _makeFieldName(table, new_field_name, seed=1):
	ws_type = _getWorkspaceType(table)
	if ws_type == u'FileSystem':
		new_field_name = new_field_name[:10]
	if _checkNewFieldName(table, new_field_name):
		if ws_type == u'FileSystem':
			new_field_name = new_field_name[:(10 - (len(str(seed)) + 1))] + "_" + str(seed)
		else:
			new_field_name = new_field_name + "_" + str(seed)
		return _makeFieldName(table, new_field_name, seed + 1)
	else:
		return new_field_name
	

def _checkNewFieldName(table, new_field_name):
	field_names = [f.name for f in arcpy.ListFields(table)]
	return new_field_name in field_names


def _getFieldTypeName(table, field_name):
	field = arcpy.ListFields(table, field_name)[0]
	ftype = field.type
	return _FIELD_TYPE_DICT[ftype]
	
	
def _getFieldDType(table, field_name):
	field = arcpy.ListFields(table, field_name)[0]
	ftype = field.type
	dtype = _FIELD_DTYPE_DICT[ftype]
	if dtype == 'U':
		dtype = "{}{}".format(dtype, field.length)
	return dtype
	

def _cleanUUID(uuid_obj):
	return str(uuid_obj).replace('-','_')


########################
##   HELPER CLASSES   ##
########################
class ZoneMatrixManager(object):
    """
    The ZoneMatrixManager class generates a matrix (2-dimensional numpy array)
    based on a provided table of zones and optional lists of zones
    representing a subset to consider as "origins" and/or "destinations." 
    
    Matrices generated by the ZoneMatrixManager has a number of rows equal
    to the length of the origin zones list and a number of columns equal to 
    the length of the destination zones list. Accessing specific cells in the
    matrix through zone indexes or labels is facilitated through various 
    methods.

    Parameters
    -----------
    zones_table: ArcGIS TableView or string
        A table listing all distinct zones potentially serving as O or D zones.
    id_field: string
        The field in `zones_table` that identifies each zone. 
    o_zones: array_like (1dim)
        A list or array of origin zone names to focus on. 
    d_zones: array_like (1dim)
        A list or array of destination zone names to focus on. 
    
    Attributes
    -----------
    zones_table: ArcGIS TableView or string
        A table listing all distinct zones potentially serving as O or D zones.
    id_field: string
        The field in `zones_table` that identifies each zone. 
    o_zones: array_like (1dim)
        A list or array of origin zones to focus on. Matrices generated by the
        ZoneMatrixManager object will have a number of rows equal to the length
        of o_zones. The array is retained as an attribute to facilitate row
        indexing.
    d_zones: array_like (1dim)
        A list or array of destination zones to focus on. Matrices generated 
        by the ZoneMatrixManager object will have a number of columns equal to
        the length of d_zones. The array is retained as an attribute to 
        facilitate column indexing.
    idx_array: np.array(1dim)
        A numpy array listing all zone id's from the zones table.
    o_mask: np.array (1dim, boolean)
        A boolean array that masks `idx_array` to facilitate row indexing.
    d_mask: np.array (1dim, boolean)
        A boolean array that masks `idx_array` to facilitate column indexing.
    """
    def __init__(self, zones_table, id_field, o_zones=None, d_zones=None):
        self.zones_table = zones_table
        self.id_field = id_field
        self._createIndexArray()
        self.setOZonesArray(o_zones)
        self.setDZonesArray(d_zones)
    
    def setZonesTable(self, zones_table, id_field=None):
        """
        Sets the `zones_table` attribute and updates the `idx_array` attribute.

        Parameters
        -----------
        zones_table: ArcGIS TableView or string (path)
            The new table listing all distinc zones potentially serving as O
            or D zones.  Once updated, matrices previously generated by this
            ZoneMatrixManager object cannot be reliably indexed.
        id_field: string
            The field in `zones_table` that identifies each zone. If `None`,
            it is assumed that the current `id_field` value is a valid field
            in the new `zones_table`. The `index_array` will be recreated 
            by referencing the `id_field` in the `zones_table`.        
        """
        _zones_table = self.zones_table
        _id_field = self.id_field
        try:
            self.zones_table = zones_table
            if id_field:
                self.id_field = id_field
            self._createIndexArray()
        except:
            self.zones_table = _zones_table
            self.id_field = _id_field
            raise AttributeError(
                    "Could not create index array based on zones_table, id_field")
    
    def _createIndexArray(self):
        #index array dtype: __idx__ (sequence), self.id_field (variable type)
        self.idx_array = mma._createZonesIndexArray(
                                self.zones_table, self.id_field)

    def setOZonesArray(self, array_1d):
        """
        Define a new list of origin zones. Once updated, matrices previously
        generated by this ZoneMatrixManager object cannot be reliably 
        indexed.

        Parameters
        ----------
        array_1d: array_like (1d)
            A list or array of origin zone names to focus on. 
        """
        self.o_zones = array_1d
        self.o_mask = np.in1d(self.idx_array[self.id_field], self.o_zones)
        
    def setDZonesArray(self, array_1d):
        """
        Define a new list of desitination zones. Once updated, matrices 
        previously generated by this ZoneMatrixManager object cannot be 
        reliably indexed.

        Parameters
        ----------
        array_1d: array_like (1d)
            A list or array of destination zone names to focus on. 
        """
        self.d_zones = array_1d
        self.d_mask = np.in1d(self.idx_array[self.id_field], self.d_zones)

    def createZeros(self, num_panes=1):  
        """
        Create a 3-d matrix initialized to zeros.  The matrix shape is
        [num_panes, len(`self.o_zones`), len(`self.d_zones`)].  If no o_zones
        or d_zones have been specified, those dimensions are sized according
        to the total number zones in `self.index_array`.

        The ZoneMatrixManager object generates matrices that have "panes".
        Each pane has a consistent number of rows and columns and represents
        distinct O-D data (a "time" pane, and "distance" pane, e.g.)

        Parameters
        ----------
        num_panes: integer
            The number of O-D panes to create.

        Returns
        --------
        numpy array
            np.array of shape [num_panes, len(self.o_zones), len(self.d_zones)]
            with all values initialized to zero.
        """      
        if np.any(self.o_zones):
            o_len = len(self.o_zones)
        else:
            o_len = len(self.idx_array)
        if np.any(self.d_zones):
            d_len = len(self.d_zones)
        else:
            d_len = len(self.idx_array)
        
        return np.zeros([num_panes, o_len, d_len])
    
    def createOnes(self, num_panes=1):
        """
        Create a 3-d matrix initialized to ones.  The matrix shape is
        [num_panes, len(`self.o_zones`), len(`self.d_zones`)].  If no o_zones
        or d_zones have been specified, those dimensions are sized according
        to the total number zones in `self.index_array`.

        The ZoneMatrixManager object generates matrices that have "panes".
        Each pane has a consistent number of rows and columns and represents
        distinct O-D data (a "time" pane, and "distance" pane, e.g.)

        Parameters
        ----------
        num_panes: integer
            The number of O-D panes to create.

        Returns
        --------
        numpy array
            np.array of shape [num_panes, len(self.o_zones), len(self.d_zones)]
            with all values initialized to ones.
        """
        if np.any(self.o_zones):
            o_len = len(self.o_zones)
        else:
            o_len = len(self.idx_array)
        if np.any(self.d_zones):
            d_len = len(self.d_zones)
        else:
            d_len = len(self.idx_array)
        
        return np.ones([num_panes, o_len, d_len])
    
    def oZoneIndex(self, zone_name, relative_to_os=True):
        """
        Given a zone_name or array of zone names, returns the row index(es)
        corresponding to the requested zones.

        Parameters
        ----------
        zone_name: variable
            The name of the zone (or list of names of zones) for which to 
            find row indexes in a matrix generated by this ZoneMatrixManager
            object.
        relative_to_os: boolean (default=True)
            If True, the row indexes returned will correspond to a matrix
            where the number of rows is equal to len(`self.o_zones`). If
            False, the row indexes returned will correspond to a matrix where
            the number of rows is equal to len(`self.index_array`)

        Returns
        --------
        [integer]
            The row index locations for the named zone(s).
        """
        if np.any(self.o_zones):
            zones = self.idx_array[self.o_mask]
        else:
            zones = self.idx_array
            return zones[np.where(
                    zones[self.id_field] == zone_name)]["__idx__"][0]
        if relative_to_os:
            return np.where(zones[self.id_field] == zone_name)[0][0]
        else:
            return zones[np.where(
                    zones[self.id_field] == zone_name)]["__idx__"][0]
        
    def dZoneIndex(self, zone_name, relative_to_ds=True):
        """
        Given a zone_name or array of zone names, returns the column index(es)
        corresponding to the requested zones.

        Parameters
        ----------
        zone_name: variable
            The name of the zone (or list of names of zones) for which to 
            find column indexes in a matrix generated by this ZoneMatrixManager
            object.
        relative_to_ds: boolean (default=True)
            If True, the column indexes returned will correspond to a matrix
            where the number of columns is equal to len(`self.d_zones`). If
            False, the column indexes returned will correspond to a matrix
            where the number of columns is equal to len(`self.index_array`)

        Returns
        --------
        [integer]
            The column index locations for the named zone(s).
        """
        if np.any(self.d_zones):
            zones = self.idx_array[self.d_mask]
        else:
            zones = self.idx_array
            return zones[np.where(
                    zones[self.id_field] == zone_name)]["__idx__"][0]
        if relative_to_ds:
            return np.where(zones[self.id_field] == zone_name)[0][0]
        else:
            return zones[np.where(
                    zones[self.id_field] == zone_name)]["__idx__"][0]
    
    def _listFlatAxes(self):
        dt_list = [("O_{}".format(self.id_field), self.idx_array.dtype[1]), 
                   ("D_{}".format(self.id_field), self.idx_array.dtype[1])]
        if np.any(self.o_zones):
            #o_mask = np.in1d(self.idx_array[self.id_field], self.o_zones)
            o_zones = self.o_zones
        else:
            o_zones = self.idx_array[self.id_field]
        if np.any(self.d_zones):
            d_zones = self.d_zones
        else:
            d_zones = self.idx_array[self.id_field]
        out_rows = [(i,j) for i in o_zones for j in d_zones]
        return np.array(out_rows, dtype=np.dtype(dt_list))
    
    def ODTableToMatrix(self, od_table, od_o_field, value_fields, 
                        od_d_field=None, delimiter=None, zeros=True, 
                        invert=False):
        """
        Generates and O-D matrix and iterates over records in an O-D table
        to assign values to the new matrix based on the indexed row
        and column locations of O and D zone names.

        Parameters
        -----------
        od_table: ArcGIS TableView or string (path)
            The table containing O-D information.
        od_o_field: String
            The field identifying the origin zone in od_table. If the table 
            has only a single O-D name field, use this field name as the
            od_o_field and provide a value for `delimiter`.
        od_d_field: String
            The field identifying the destination zone in od_table. If the
            table has only a single O-D name field, the od_d_field is not
            needed.
        value_fields: [String,...]
            The O-D values to assign to the output array. The number of
            value_fields provided determines the number of panes in the
            output array.
        delimiter: string
            If od_table has only a single O-D name field, the delimiter
            defines the string on which to split values in that field to
            deterimine the O and D zone names for each row.
        zeros: boolean (default=True)
            If True, the output array will be initialized to zeros.  Any
            O-D pairs in the array not found in od_table will show up as
            zeros. These cannot be differentiated from values of zero 
            found in the od_table. If False, the output array will be 
            initialized to ones.  Any O-D pairs in the array not found in
            od_table will show up as ones.  These cannot be differentiated
            from values of one found in the od table (but see invert below).
        invert: boolean (default=False)
            If True, the output array will be multiplied by -1 when 
            initialized. This only applies when zeros=False. Any O-D pairs
            in the array not found in the od_table will show up as -1. These
            are easily distinguished from valid O-D values (which are 
            typically non-negative numbers).

        Returns
        --------
        numpy array
            np.array of shape [len(val_fields), len(self.o_zones), 
            len(self.d_zones)] where the first pane (index=0) provides O-D values
            for the first value field, the second pane (index=1) provides O-D
            values for the second value fields, and so on.
        """
        #print od_o_field, od_d_field, od_value_fields
        #setup output matrix
        o_zones = self.idx_array
        d_zones = self.idx_array
        if np.any(self.o_zones):
            o_zones = self.idx_array[self.o_mask]
        if np.any(self.d_zones):
            d_zones = self.idx_array[self.d_mask]
    
        mat_shape = [len(value_fields), len(o_zones), len(d_zones)]
        if zeros:
            matrix = np.zeros(mat_shape, "<f8")
        else:
            matrix = np.ones(mat_shape, "<f8")
        if invert:
            matrix *= -1
        print matrix.shape
        
        #setup table specs
        zone_id_kind = self.idx_array.dtype[1].kind
        fields = [od_o_field]
        if od_d_field:
            fields.append(od_d_field)
        fields.extend(value_fields)
    
        #iterate over table
        with arcpy.da.SearchCursor(od_table, fields) as c:
            for r in c:
                #determine o,d and values
                if od_d_field:
                    o, d = r[:2]
                    values = r[2:]
                else:
                    name = r[0]
                    o, d = name.split(delimiter, 1)
                    values = r[1:]
                if zone_id_kind == 'i' or zone_id_kind == 'f':
                        o = float(o)
                        d = float(d)
                #store table data in matrix array
                for i, v in enumerate(values):              
                    if o != d:
                        try:
                            o_idx = self.oZoneIndex(o, True)
                            d_idx = self.dZoneIndex(d, True)
                            #o_idx = np.where(o_zones[self.id_field] == o)[0][0]
                            #d_idx = np.where(d_zones[self.id_field] == d)[0][0]
                            matrix[i][o_idx][d_idx] = float(v)
                        except IndexError:
                            continue
        return matrix

########################
## ANALYSIS FUNCTIONS ##
########################
	
def listStudyAreaZones(transit_skim_references, transit_time_cutoff, auto_skim_references, auto_time_cutoff,
							select_zones, output_table):
	"""
	Produces a table listing zones in the transit projet study area based 
	on travel times to the project by transit and driving.
	
	Parameters
	----------
	transit_skim_references : File (.json)
		A (list of) skim reference configuration file(s) to search for
		study area zones reachable within `transit_time_cutoff` from
		zones included in `select_zones`.
	transit_time_cutoff : Double
		The transit travel time tolerance used to determine a zone's 
		inclusion in the project study area.
	auto_skim_references : File (.json)
		A (list of) skim reference configuration file(s) to search for
		study area zones reachable within `auto_time_cutoff` from
		zones included in `select_zones`.
	auto_time_cutoff : Double
		The auto (highway) travel time tolerance used to determine a  
		zone's inclusion in the project study area.
	select_zones : [Variant,...]
		A list of values corresponding to Zone IDs.  The list includes 
		all zones considered to be "within the project limits.
	output_table : ArcGIS Table
		The output table to be produced by the tool, listing all zones
		in the project area.  The table includes zones in `select_zones`
		as well as those reachable by transit within `transit_time_cutoff`
		and by auto within `auto_time_cutoff`.
		
	Returns
	--------
	None
		Nothing is returned by the function.  A new output table is 
		generated at the path specified by `output_table`.
	
	See Also
	--------
	gp_listStudyAreaZones
	mapStudyArea
	mma.Skim
	mma.jsonToSkim
	"""
	destinations = []
	
	for transit_skim_reference in transit_skim_references:
		destinations += _listDestinations(transit_skim_reference, select_zones, transit_time_cutoff)
	for auto_skim_reference in auto_skim_references:
		destinations += _listDestinations(auto_skim_reference, select_zones, auto_time_cutoff)
		
	destinations = list(set(destinations))
	
	if type(destinations[0]) is str or type(destinations[0]) is unicode:
		dt = np.dtype([("STUDY_AREA", "|S150")])
	else:
		dt = np.dtype([("STUDY_AREA", "<f8")])
		
	array = np.array([(d,) for d in destinations], dtype=dt)
	arcpy.da.NumPyArrayToTable(array, output_table)


def mapStudyArea(study_area_table, sa_zone_field, zones_fc, zone_id_field, layer_name=None, output_fc=None):
	"""
	Using a list of study area zones and a related zones feature class, 
	produces a feature layer showing the project study area. Optionally, 
	produces a feature class outlining the study area.
	
	Parameters
	-----------
	study_area_table : ArcGIS Table or Table View
		The table listing all zones included in the project study area.
	sa_zone_field : String
		The field in `study_area_table` that identifies each zone in the
		project study area.
	zones_fc : ArcGIS Feature Class or Feature Layer
		A polygon feature class having zones with ID values corresponding
		to those in `sa_zone_field`.
	zone_id_field : String
		The field in `zones_fc` that contains zone ID values.  It should
		be of the same data type as `sa_zone_field`.
	layer_name : String, optional
		A recongizable name for the feature layer to be produced.
		Default is None, indicating an auto-generated unique name
		will be applied to the output feature layer.
	output_fc : String, optional
		The full path to the output feature class to be produced, 
		outlining the project study area (dissolved zonal polygons).
		Default is None, indicating no output feature class will be
		produced.
		
	Returns
	--------
	out_layer : ArcGIS feature layer
		A feature layer showing the study area limits based on matching
		`zones_fc` features included in `study_area_table`.  Also, 
		optionally outptus a feature class outlining the study area to the
		path specified by `output_fc`.
	
	See Also
	--------
	gp_mapStudyArea
	listStudyAreaZones	
	"""
	#list zones in the table
	with arcpy.da.SearchCursor(study_area_table, sa_zone_field) as c:
		zones = sorted({r[0] for r in c})
			
	#build an expression for the zones feature class/zone id field
	field_expr = arcpy.AddFieldDelimiters(zones_fc, zone_id_field)
	quote_char = ""
	if _getFieldTypeName(zones_fc, zone_id_field) == "TEXT":
		quote_char = "'"
	expr = " OR ".join(["{} = {}{}{}".format(field_expr, quote_char, z, quote_char) for z in zones])
	
	#create a feature layer using the expression as the def query
	if not layer_name:
		layer_name = "Study_area_{}".format(_cleanUUID(uuid.uuid1()))
	out_layer = arcpy.MakeFeatureLayer_management(zones_fc, layer_name, expr)
	
	if output_fc:
		arcpy.Dissolve_management(out_layer, output_fc)
		
	return out_layer


def createStopToStreetConnectors(stops_layer, streets_layer, search_tolerance, output_ws, feature_dataset):
	"""
	Create a line feature connecting each stop feature to a street 
	feature.

	This function snaps transit stops to the street feature class, 
	generates connector lines between the original stop location and
	the snapped stop location, and adds vertices to the street features 
	at the locations of the snapped stops. These steps ensure good 
	connectivity in the network dataset based on GTFS feeds. It mimics 
	step 2 in ESRI's Add GTFS to Network Dataset toolbox for users
	having the ArcGIS Basic license.

	Parameters
	----------
	stops_layer : ArcGIS Feature Class or Feature Layer
		Point features representing GTFS stop locations.
	streets_layer : ArcGIS Feature Class or Feature Layer
		Line features representing the pedestrian network from which 
		`stops_layer` features will be accessed.
	search_tolerance : String (Linear Unit)
		The distance from `stops_layer` features to search for potential
		`streets_layer` features to snap stops to streets.
	output_ws : Geodatabase
		The file or personal geodatabase in which output tables and 
		will be stored.
	feature_dataset : ArcGIS Feature Dataset
		The feature dataset within `output_ws` in which output
		feature classes will be stored.
	
	Returns
	--------
	None
		Nothing is returned by the function.  Several tables and feature
		classes are generated in the `output_ws` and `feature_dataset`
		workspaces:
		- Connectors_Stops2StreetsTable (Table, interim)
		- Connectors_Stops2Streets (Feature class, final)
		- Stops_Snapped2Streets (Feature class, final)
	
	See Also
	---------
	gp_StopsToStreetsConnectors
	"""
	#####
	##### Need to add functionality to control for parent/child stations, 
	##### station entrances (location_type = 2), wheelchair boarding
	#####
		
	#prepare output
	out_table = "{}\\Connectors_Stop2StreetsTable".format(output_ws)
	if feature_dataset:
		out_fc = "{}\\Connectors_Stops2Streets".format(feature_dataset)
	pts_fc = "{}\\Stops_Snapped2Streets".format(feature_dataset)  
	pts_fc_alt = "{}\\Stops_Snapped2Streets".format(output_ws)  
	dt = np.dtype([('stop_id', '|S255'), ('X1', '<f8'), ('Y1', '<f8'),
									('X2', '<f8'), ('Y2', '<f8')])
	snap_dt =np.dtype([('stop_id', '|S255'), ('X1', '<f8'), ('Y1', '<f8')])
	
	#create empty containers to hold new line feature details and erros
	out_rows = []
	snaps = []
	#iterate over stops, getting their point geometries for analysis
	#the stop pt geom will be the beggining of the new line feature
	sr = arcpy.Describe(stops_layer).spatialReference
	arcpy.AddMessage("iterating over stops features")
	with arcpy.da.SearchCursor(stops_layer, ["stop_id", "SHAPE@"], spatial_reference=sr) as stops_c:
		for stops_r in stops_c:
			stop_id, stop_pt = stops_r
			#select any street features within the search tolerance
			arcpy.SelectLayerByLocation_management(streets_layer,"INTERSECT",stop_pt,
												   search_tolerance,"NEW_SELECTION")
			#create empty containers for identifying the nearest street feature and its distance from the stop
			min_dist = [float('inf')]
			min_line = None
			#for each nearby street features, get the distance from the stop; keep the nearest street feature
			with arcpy.da.SearchCursor(streets_layer,"SHAPE@", spatial_reference=sr) as streets_c:
				for streets_r in streets_c:
					line = streets_r[0]
					dist = stop_pt.distanceTo(line)
					if dist < min_dist:
						min_dist = dist
						min_line = line
			#if a nearest street feature was found, buffer the point and get the intersection of the buffer
			#with the nearest street feature.  This will be the end of the new line feature
			if min_dist < float('inf'):
				snap_pt = min_line.snapToLine(stop_pt)
				out_row = (stop_id, stop_pt.centroid.X, stop_pt.centroid.Y, snap_pt.centroid.X, snap_pt.centroid.Y)
				out_rows.append(out_row)
				snap = (stop_id, snap_pt.centroid.X, snap_pt.centroid.Y)
				snaps.append(snap)
		#clean up and export output
		arcpy.AddMessage("exporting output ({} connectors found)".format(len(out_rows)))
		arcpy.SelectLayerByAttribute_management(streets_layer, "CLEAR_SELECTION")
		out_array = np.array(out_rows, dt)
		snap_array = np.array(snaps, snap_dt)        
		arcpy.da.NumPyArrayToTable(out_array, out_table)
		arcpy.XYToLine_management(out_table, out_fc, 'X1', 'Y1', 'X2', 'Y2', "GEODESIC", 'stop_id', sr)
	try:
			arcpy.da.NumPyArrayToFeatureClass(snap_array, pts_fc, ['X1', 'Y1'], sr)
	except:
		arcpy.da.NumPyArrayToFeatureClass(snap_array, pts_fc_alt, ['X1', 'Y1'], sr)
		pts_fc = pts_fc_alt
		
	#integrate new lines and streets layer
	arcpy.AddMessage("integrating vertices into streets layer")
	arcpy.Integrate_management([pts_fc, streets_layer])  #out_fc   
	
	
def travelTimeSavings(zone_table, zone_id_field, base_skim_ref, build_skim_ref,
                      trip_table, trip_o_field, trip_d_field, trip_val_field,
                      o_zone_table, o_zone_field, out_table):
    """
    Estimates average travel time savings in a build scenario relative to a
    base sceanrio using a consistent trip table. 
    
    When the build condition improves travel times between commmonly traveled 
    O-D pairs (discerned from the trip table), the travel time savings will be
    high.

    Parameters
    -----------
    zone_table: ArcGIS TableView or string
        A table listing all distinct zones in the skims and trip tables.
    zone_id_field: string
        The field in `zone_table` that identifies each zone. Values in this 
        field should correspond to values in the skim tables' and trip table's
        origin and destination zone columns.
    base_skim_ref: string
        The path to the skim reference .json file to use as the base skim. The 
        skim reference points to a skim table and includes metadata for
        appropriately parsing origin, destination, and impedance fields.
    build_skim_ref: string
        The path to the skim reference .json file to use as the build skim. 
        The skim reference points to a skim table and includes metadata for
        appropriately parsing origin, destination, and impedance fields.
    trip_table: ArcGIS TableView or string
        An origin-destination table containing the number of trips between OD
        pairs.
    trip_o_field: string
        The field in the `trip_table` that identifies the origin zone of the 
        OD pair.
    trip_d_field: string
        The field in the `trip_table` that identifies the destination zone of
        the OD pair.
    trip_val_field: string
        The field in the `trip_table` that identifies the number of trips
        between the origin zone and the destination zone.
    o_zone_table: ArcGIS TableView or string
        A table listing the origin zones within the study area to limit the 
        travel time savings analysis to this specific subset of zones.
    o_zone_field: string
        The field in `o_zone_table` that identifies each study area zone.
    out_table: string
        The path to the output file to be generated with travel time savings
        results summarized.

    Returns
    --------
    None
        Nothing is retured by the function. It will output a table listing all zones
        in the `o_zone_table` and the average travel time change for trips from 
        each zone ("AvgTTChg"), the total number of trips from each zone ("SumTrips"),
        and the total travel time savings from each zone ("SumTTChg" = "AvgTTChg" *
        "SumTrips").  For study-area-wide average travel time savings, the column sum
        of "SumTTChg" may be divided by the column sum of "SumTrips".

    See Also
    ---------
    mma.jsonToSkim
    mma.Skim
    
    Notes
    ------
    The zone table provides a consistent frame of reference for indexing O-D
    values in the base skim, build skim, and trip tables.  This allows all
    O-D impedances and trip totals to be stored in a matrix for efficient
    processing.
    """
    o_zone_array = mma._createZonesIndexArray(
                            o_zone_table, o_zone_field)[o_zone_field]
    skim_obj_1 = mma.jsonToSkim(base_skim_ref)
    skim_obj_2 = mma.jsonToSkim(build_skim_ref)
    skim_table_1 = "\\".join([skim_obj_1.path, skim_obj_1.table])
    skim_table_2 = "\\".join([skim_obj_2.path, skim_obj_2.table])

    zmm = ZoneMatrixManager(zone_table, zone_id_field, o_zone_array)
    
    skim_mat_1 = zmm.ODTableToMatrix(skim_table_1, skim_obj_1.o_field,                                      
                                     [skim_obj_1.impedance_field],
									 skim_obj_1.d_field, 
                                     skim_obj_1.delimiter, 
                                     zeros=False, invert=True)
    skim_mat_2 = zmm.ODTableToMatrix(skim_table_2, skim_obj_2.o_field,                                      
                                     [skim_obj_2.impedance_field],
									 skim_obj_2.d_field, 
                                     skim_obj_2.delimiter, 
                                     zeros=False, invert=True)
    
    comp_mask = np.where(skim_mat_1 == -1)
    skim_mat_2[comp_mask] = -1
    
    diff_mat = np.subtract(skim_mat_2, skim_mat_1)
    
    trip_mat = zmm.ODTableToMatrix(trip_table, trip_o_field, trip_val_field, 
                                   trip_d_field, zeros=True, invert=False)
    
    prod_mat = np.multiply(diff_mat[0], trip_mat[0])
    row_sumprods = np.sum(prod_mat, axis=1)
    row_sums = np.sum(trip_mat[0], axis=1)
    
    row_avgs = np.divide(row_sumprods, row_sums)
    row_avgs[np.isnan(row_avgs)] = 0
    
    o_zones_found = zmm.idx_array[np.in1d(zmm.idx_array[zmm.id_field], 
                                          zmm.o_zones)][zmm.id_field]
    out_array = np.rec.fromarrays((o_zones_found, row_avgs, 
                                    row_sums, row_sumprods),
                                      names=("ZONE", "AvgTTChg", 
                                            "SumTrips", "SumTTChg"))
        
    arcpy.da.NumPyArrayToTable(out_array, out_table)	
	
	
######################
## ANALYSIS HELPERS ##
######################
	
def _listDestinations(skim_reference, select_zones, time_cutoff):
	destinations = []
	skim_obj = mma.jsonToSkim(skim_reference)
	if skim_obj.table_type == "arcpy":
		skim_table = "{}\\{}".format(skim_obj.path, skim_obj.table)
		skim_fields = skim_obj.getSkimFields()
		
		expr = _buildExpr(skim_obj, select_zones, time_cutoff)
		arcpy.AddMessage(expr)
		with arcpy.da.SearchCursor(skim_table, skim_fields, where_clause=expr) as c:
			for r in c:
				if skim_obj.d_field:
					d = r[skim_obj.d_idx]
				else:
					d = r[skim_obj.o_idx].split(skim_obj.delimiter, 1)[1]
				destinations.append(d)
	return list(set(destinations))

	
def _buildExpr(skim_obj, select_zones, time_cutoff):
	skim_table = "{}\\{}".format(skim_obj.path, skim_obj.table)
	zone_field= arcpy.AddFieldDelimiters(skim_table, skim_obj.o_field)
	imp_field = arcpy.AddFieldDelimiters(skim_table, skim_obj.impedance_field)
	quote_char = ""
	if _getFieldTypeName(skim_table, skim_obj.o_field) == "TEXT":
		quote_char = "'"
	comp, wildcard = " LIKE ", "%"
	if skim_obj.d_field:
		comp, wildcard = " = ", ""
	expr = " OR ".join(["{}{}{}{}{}{}".format(zone_field, comp, quote_char, zone, wildcard, quote_char) for zone in select_zones])
	expr = "(" + expr + ") AND {} <= {}".format(imp_field, time_cutoff)
	return expr
	
	

	
	
	
